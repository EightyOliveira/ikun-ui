"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/core/unplugin.ts
var _unplugin = require('unplugin');

// src/core/transform.ts
var _path = require('path');
var _compilersfc = require('@vue/compiler-sfc');
var _magicstring = require('magic-string'); var _magicstring2 = _interopRequireDefault(_magicstring);
function supportScriptName(code, id, options) {
  var _a;
  const { mode } = options;
  let s;
  const str = () => s || (s = new (0, _magicstring2.default)(code));
  const { descriptor } = _compilersfc.parse.call(void 0, code);
  if (!descriptor.script && descriptor.scriptSetup && !((_a = descriptor.scriptSetup.attrs) == null ? void 0 : _a.extendIgnore)) {
    const result = _compilersfc.compileScript.call(void 0, descriptor, { id });
    const name = typeof result.attrs.name === "string" ? result.attrs.name : nameProcess(id, mode);
    const lang = result.attrs.lang;
    const inheritAttrs = result.attrs.inheritAttrs;
    if (name || inheritAttrs) {
      str().appendLeft(0, `<script ${lang ? `lang="${lang}"` : ""}>
import { defineComponent } from 'vue'
export default defineComponent({
  ${name ? `name: "${name}",` : ""}
  ${inheritAttrs ? `inheritAttrs: ${inheritAttrs !== "false"},` : ""}
})
<\/script>
`);
    }
    const map = str().generateMap({ hires: true });
    const filename = _path.basename.call(void 0, id);
    map.file = filename;
    map.sources = [filename];
    return {
      map,
      code: str().toString()
    };
  } else {
    return null;
  }
}
function nameProcess(id, mode) {
  const commonId = id.replace(/\\/g, "/").split("?")[0];
  if (typeof mode === "string") {
    const parseUrl = _path.parse.call(void 0, commonId);
    const fileName = parseUrl.name;
    const relativeName = parseUrl.dir.split("/").at(-1);
    if (mode === "relativeName")
      return camelize(`${relativeName}-${fileName}`);
  }
  if (typeof mode === "function")
    return mode(commonId);
  return "";
}
function camelize(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "").replace(/(\w)/, (_, c) => c.toUpperCase());
}

// src/core/unplugin.ts
var unplugin_default = _unplugin.createUnplugin.call(void 0, (options = {}) => {
  return {
    name: "unplugin-vue-setup-extend-plus",
    enforce: "pre",
    transformInclude(id) {
      return id.endsWith(".vue");
    },
    async transform(code, id) {
      if (options.mode && options.mode === "none")
        return null;
      if (/\.vue$/.test(id) || /\.vue\?.*type=script.*/.test(id))
        return supportScriptName.call(this, code, id, options);
      return null;
    }
  };
});



exports.unplugin_default = unplugin_default;
